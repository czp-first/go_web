// 8.4 RPC
// 前面几个小节介绍了如何基于Socket和HTTP来编写网络应用，通过学习了解了Socket和HTTP采用的是类似"信息交换"模式，即客户端发送一条信息到服务端,然后(一般来说)服务器端都会返回一定的信息以表示响应。客户端和服务端之间约定了交互信息的格式，以便双方都能够解析交互所产生的信息。但是很多独立的应用并没有采用这种模式，而是采用类似常规的函数调用的方式来完成想要的功能
// RPC就是想实现函数调用模式的网络化。客户端就像调用本地函数一样，然后客户端把这些参数打包之后通过网络传递到服务端，服务端解包到处理过程中执行，然后执行的结果反馈给客户端
// RPC(Remote Procedure Call Protocol) -- 远程过程调用协议，是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。它嘉定某些传输协议的存在，如TCP和UDP，以便为通信程序之间携带信息数据。通过它可以使函数调用模式网络化。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易

// RPC工作原理
// 运行时，一次客户机对服务器的RPC调用，其内部操作大致有如下十步：
//	1. 调用客户端句柄：执行传送参数
//	2. 调用本地系统内核发送网络消息
//	3. 消息传送到远程主机
//	4. 服务器句柄得到消息并取得参数
//	5. 执行远程过程
//	6. 执行的过程将结果返回服务器句柄
//	7. 服务器句柄返回结果，调用远程系统内核
//	8. 消息传回本地主机
//	9. 客户句柄由内核接收消息
//	10. 客户接收句柄返回的数据

// go RPC
// go标准包中已经提供了对RPC的支持，而且支持三个级别的RPC:TCP、HTTP、JSONRPC。但go的RPC包是独一无二的RPC，它和传统的RPC系统不同，它只支持go开发的服务器与客户端之间的交互，因为在内部，它们采用了Gob来编码

// go RPC的函数只有符合下面的条件才能被远程访问，不然会被忽略，详细的要求如下：
//	函数必须是导出的(首字母大写)
//	必须有两个导出类型的参数
//	第一个参数是接收的参数，第二个参数是返回给客户端的参数，第二个参数必须是指针类型的
//	函数还要有一个返回值error
// 举个例子，正确的RPC函数格式如下
func (t *T) MethodName(argType T1, replyType *T2) error
// T、T1和T2类型必须能被encoding/gob包编解码
// 任何的RPC都需要通过网络来传递数据，Go RPC可以利用HTTP和TCP来传递数据，利用HTTP的好处是可以直接复用net/http里面的一些函数。详细的例子请看下面的实现
// http_rpc_server.go
// 上面的例子，注册了一个Arith的RPC服务，然后通过rpc.HandleHTTP函数把该服务注册到了HTTP协议上，然后就可以利用http的方式来传递函数了
// 客户端代码: http_rpc_client.go

// TCP RPC
// 上面实现了基于HTTP协议的RPC，接下来要实现基于TCP协议的RPC
// tcp_rpc_server.go
// 上面这个代码和http的服务器相比，不同在于：在此处采用了TCP协议，然后需要自己控制连接，当有客户端连接上来后，需要把这个连接交给rpc来处理
// 这是一个阻塞型的单用户的程序，如果想要实现多并发，那么可以使用goroutine来实现，前面在socket小节的时候已经介绍过如何处理goroutine
// TCP实现的RPC客户端:tcp_rpc_client.go

// JSON RPC
// JSON RPC是数据编码采用了JSON，而不是gob编码，其他和上面介绍的RPC概念一模一样，
// 服务器代码：json_rpc_server.go
// 通过示例可以看出json-rpc是基于TCP协议实现的，目前它还不支持HTTP方式
// 客户端代码：json_rpc_client.go



































